package us.spotco.malwarescanner;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.AsyncTask;
import android.os.Environment;
import android.widget.TextView;

import com.google.common.hash.Hashing;
import com.google.common.io.Files;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class MalwareScanner {

    private Context context = null;
    private TextView log = null;
    private AsyncTask<Boolean, String, String> malwareScannerTask = null;

    public MalwareScanner(Context context, TextView log) {
        this.context = context;
        this.log = log;
    }

    public void startScanner(boolean scanSystem, boolean scanApps, boolean scanInternal, boolean scanExternal) {
        if(Database.doesDatabaseExist()) {
            malwareScannerTask = new MalwareScannerTask().execute(scanSystem, scanApps, scanInternal, scanExternal);
        } else {
            log.append("No database found... download one first!\n");
        }
    }

    public void stopScanner() {
        malwareScannerTask.cancel(true);
    }

    public boolean isScannerRunning() {
        if (malwareScannerTask == null) {
            return false;
        }
        return malwareScannerTask.getStatus().equals(AsyncTask.Status.PENDING) || malwareScannerTask.getStatus().equals(AsyncTask.Status.RUNNING);
    }

    public class MalwareScannerTask extends AsyncTask<Boolean, String, String> {

        @Override
        protected void onPreExecute() {
            log.append("Initiating scan...\n");
        }

        @Override
        protected void onCancelled() {
            log.append("Scan cancelled\n");
        }

        @Override
        protected String doInBackground(Boolean... booleans) {
            boolean scanSystem = booleans[0];
            boolean scanApps = booleans[1];
            boolean scanInternal = booleans[2];
            boolean scanExternal = booleans[3];

            Set<File> filesToScan = new HashSet<>();

            if (scanSystem) {
                filesToScan.addAll(getFilesRecursive(Environment.getRootDirectory()));
            }
            if (scanApps) {
                for(ApplicationInfo packageInfo : context.getPackageManager().getInstalledApplications(PackageManager.GET_META_DATA)) {
                    filesToScan.add(new File(packageInfo.sourceDir));
                }
            }
            if (scanInternal) {
                filesToScan.addAll(getFilesRecursive(Environment.getExternalStorageDirectory()));
            }
            if (scanExternal) {
                filesToScan.addAll(getFilesRecursive(new File("/storage")));
            }
            publishProgress(filesToScan.size() + " files pending scan");

            HashMap<String, File> fileHashesMD5 = new HashMap<String, File>();
            HashMap<String, File> fileHashesSHA256 = new HashMap<String, File>();
            for(File file : filesToScan) {
                fileHashesMD5.put(getFileMD5Sum(file), file);
                fileHashesSHA256.put(getFileSHA256Sum(file), file);
            }
            publishProgress("Calculated MD5 and SHA256 hashes for all files");

            for(Map.Entry<String, File> file : fileHashesMD5.entrySet()) {
                String result = Database.checkInDatabase(file.getKey());
                if(result != null) {
                    publishProgress(file.getValue() + " detected as " + result);
                }
            }
            publishProgress("Checked all MD5 hashes against signature databases");

            for(Map.Entry<String, File> file : fileHashesSHA256.entrySet()) {
                String result = Database.checkInDatabase(file.getKey());
                if(result != null) {
                    publishProgress(file.getValue() + " detected as " + result);
                }
            }
            publishProgress("Checked all SHA256 hashes against signature databases");
            return null;
        }

        @Override
        protected void onProgressUpdate(String... progress) {
            log.append(progress[0] + "\n");
        }

        @Override
        protected void onPostExecute(String result) {
            log.append("Scan complete!\n");
        }

    }

    private Set<File> getFilesRecursive(File root) {
        Set<File> filesAll = new HashSet<>();

        File[] files = root.listFiles();
        if (files != null && files.length > 0) {
            for (File f : files) {
                if (f.isDirectory()) {
                    Set<File> filesTmp = getFilesRecursive(f);
                    if (filesTmp != null) {
                        filesAll.addAll(filesTmp);
                    }
                } else {
                    filesAll.add(f);
                }
            }
        }

        return filesAll;
    }

    private String getFileMD5Sum(File file) {
        try {
            return Files.asByteSource(file).hash(Hashing.md5()).toString();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String getFileSHA256Sum(File file) {
        try {
            return Files.asByteSource(file).hash(Hashing.sha256()).toString();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

}
