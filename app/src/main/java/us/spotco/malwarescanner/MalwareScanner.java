package us.spotco.malwarescanner;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.AsyncTask;
import android.os.Environment;
import android.widget.TextView;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class MalwareScanner {

    private static Context context = null;
    private static TextView log = null;
    private static AsyncTask<Boolean, String, String> malwareScannerTask = null;

    private static HashMap<String, File> fileHashesMD5 = new HashMap<>();
    private static HashMap<String, File> fileHashesSHA1 = new HashMap<>();
    private static HashMap<String, File> fileHashesSHA256 = new HashMap<>();

    public MalwareScanner(Context context, TextView log) {
        MalwareScanner.context = context;
        MalwareScanner.log = log;
    }

    public static void startScanner(boolean scanSystem, boolean scanApps, boolean scanInternal, boolean scanExternal) {
        if (Database.doesDatabaseExist()) {
            malwareScannerTask = new MalwareScannerTask().execute(scanSystem, scanApps, scanInternal, scanExternal);
        } else {
            log.append("No database found... download one first!\n");
        }
    }

    public void stopScanner() {
        malwareScannerTask.cancel(true);
    }

    public boolean isScannerRunning() {
        return malwareScannerTask != null && (malwareScannerTask.getStatus().equals(AsyncTask.Status.PENDING) || malwareScannerTask.getStatus().equals(AsyncTask.Status.RUNNING));
    }

    public static class MalwareScannerTask extends AsyncTask<Boolean, String, String> {

        @Override
        protected void onPreExecute() {
            log.append("Initiating scan...\n");
            fileHashesMD5.clear();
            fileHashesSHA1.clear();
            fileHashesSHA256.clear();
        }

        @Override
        protected void onCancelled() {
            log.append("Scan cancelled\n");
        }

        @Override
        protected String doInBackground(Boolean... booleans) {
            boolean scanSystem = booleans[0];
            boolean scanApps = booleans[1];
            boolean scanInternal = booleans[2];
            boolean scanExternal = booleans[3];

            Set<File> filesToScan = new HashSet<>();

            if (scanSystem) {
                filesToScan.addAll(getFilesRecursive(Environment.getRootDirectory()));
            }
            if (scanApps) {
                for (ApplicationInfo packageInfo : context.getPackageManager().getInstalledApplications(PackageManager.GET_META_DATA)) {
                    filesToScan.add(new File(packageInfo.sourceDir));
                }
            }
            if (scanInternal) {
                filesToScan.addAll(getFilesRecursive(Environment.getExternalStorageDirectory()));
            }
            if (scanExternal) {
                filesToScan.addAll(getFilesRecursive(new File("/storage")));
            }
            publishProgress(filesToScan.size() + " files pending scan");

            Database.loadDatabase(Database.signatureDatabases);
            publishProgress("Loaded " + Database.signaturesMD5.size() + " MD5 signatures");
            publishProgress("Loaded " + Database.signaturesSHA1.size() + " SHA-1 signatures");
            publishProgress("Loaded " + Database.signaturesSHA256.size() + " SHA-256 signatures\n");

            publishProgress("Hashing files...");
            for (File file : filesToScan) {
                getFileHashes(file);
            }
            publishProgress("Calculated MD5/SHA-1/SHA-256 hashes for all files\n");

            if (Database.signaturesMD5.size() > 0) {

                for (Map.Entry<String, File> file : fileHashesMD5.entrySet()) {
                    if (Database.signaturesMD5.containsKey(file.getKey())) {
                        String result = Database.signaturesMD5.get(file.getKey());
                        publishProgress(file.getValue() + " detected as " + result);
                    }
                }
                publishProgress("Checked all MD5 hashes against signature databases\n");
            } else {
                publishProgress("No MD5 signatures available\n");
            }

            if (Database.signaturesSHA1.size() > 0) {
                for (Map.Entry<String, File> file : fileHashesSHA1.entrySet()) {
                    if (Database.signaturesSHA1.containsKey(file.getKey())) {
                        String result = Database.signaturesSHA1.get(file.getKey());
                        publishProgress(file.getValue() + " detected as " + result);
                    }
                }
                publishProgress("Checked all SHA-1 hashes against signature databases\n");
            } else {
                publishProgress("No SHA-1 signatures available\n");
            }

            if (Database.signaturesSHA256.size() > 0) {
                for (Map.Entry<String, File> file : fileHashesSHA256.entrySet()) {
                    if (Database.signaturesSHA256.containsKey(file.getKey())) {
                        String result = Database.signaturesSHA256.get(file.getKey());
                        publishProgress(file.getValue() + " detected as " + result);
                    }
                }
                publishProgress("Checked all SHA-256 hashes against signature databases\n");
            } else {
                publishProgress("No SHA-256 signatures available\n");
            }

            System.gc();

            return null;
        }

        @Override
        protected void onProgressUpdate(String... progress) {
            log.append(progress[0] + "\n");
        }

        @Override
        protected void onPostExecute(String result) {
            log.append("Scan complete!\n\n\n\n\n");
        }

    }

    private static Set<File> getFilesRecursive(File root) {
        Set<File> filesAll = new HashSet<>();

        File[] files = root.listFiles();
        if (files != null && files.length > 0) {
            for (File f : files) {
                if (f.isDirectory()) {
                    Set<File> filesTmp = getFilesRecursive(f);
                    if (filesTmp != null) {
                        filesAll.addAll(filesTmp);
                    }
                } else {
                    filesAll.add(f);
                }
            }
        }

        return filesAll;
    }

    private static void getFileHashes(File file) {
        try {
            InputStream fis = new FileInputStream(file);

            byte[] buffer = new byte[4096];
            int numRead;

            MessageDigest digestMD5 = MessageDigest.getInstance("MD5");
            MessageDigest digestSHA1 = MessageDigest.getInstance("SHA-1");
            MessageDigest digestSHA256 = MessageDigest.getInstance("SHA-256");

            do {
                numRead = fis.read(buffer);
                if (numRead > 0) {
                    digestMD5.update(buffer, 0, numRead);
                    digestSHA1.update(buffer, 0, numRead);
                    digestSHA256.update(buffer, 0, numRead);
                }
            } while (numRead != -1);

            fis.close();

            fileHashesMD5.put(String.format("%032x", new BigInteger(1, digestMD5.digest())), file);
            fileHashesSHA1.put(String.format("%032x", new BigInteger(1, digestSHA1.digest())), file);
            fileHashesSHA256.put(String.format("%064x", new BigInteger(1, digestSHA256.digest())), file);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
