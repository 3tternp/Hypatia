/*
Hypatia: A realtime malware scanner for Android
Copyright (c) 2017-2018 Divested Computing Group

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
package us.spotco.malwarescanner;

import android.app.Activity;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.Context;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Environment;
import android.os.SystemClock;
import android.widget.TextView;

import androidx.core.app.NotificationCompat;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.Set;

class MalwareScanner extends AsyncTask<Set<File>, Object, String> {

    private Context context = null;
    private TextView logOutput = null;
    private boolean userFacing = false;
    private NotificationManager notificationManager = null;
    private long scanTime = 0;
    private final HashMap<String, File> fileHashesMD5 = new HashMap<>();
    private final HashMap<String, File> fileHashesSHA1 = new HashMap<>();
    private final HashMap<String, File> fileHashesSHA256 = new HashMap<>();
    public boolean running = false;

    public MalwareScanner(Activity activity, Context context, boolean userFacing) {
        this.context = context;
        this.userFacing = userFacing;
        if (activity != null) {
            logOutput = activity.findViewById(R.id.txtLogOutput);
        } else {
            notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                NotificationChannel detectionChannel = new NotificationChannel("DETECTION", context.getString(R.string.lblNotificationMalwareDetectionTitle), NotificationManager.IMPORTANCE_HIGH);
                detectionChannel.setDescription(context.getString(R.string.lblNotificationMalwareDetectionDescription));
                notificationManager.createNotificationChannel(detectionChannel);
            }
        }
    }

    private void logResult(String result, boolean userFacingOnly) {
        if (userFacing) {
            logOutput.append(result);
            if (!(result.length() <= 3)) {
                logOutput.append("\n");
            }
        } else if (!userFacingOnly) {
            String[] malwareDetect = result.split(" in ");
            NotificationCompat.Builder mBuilder =
                    new NotificationCompat.Builder(context)
                            .setSmallIcon(R.drawable.ic_notification)
                            .setContentTitle(context.getText(R.string.lblNotificationRealtimeDetection) + " " + malwareDetect[0])
                            .setContentText(malwareDetect[1])
                            .setPriority(Notification.PRIORITY_MAX)
                            .setDefaults(Notification.DEFAULT_VIBRATE);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                mBuilder.setVisibility(NotificationCompat.VISIBILITY_SECRET);
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                mBuilder.setChannelId("DETECTION");
            }
            notificationManager.notify(new Random().nextInt(), mBuilder.build());
        }
    }

    @Override
    protected final void onPreExecute() {
        scanTime = SystemClock.elapsedRealtime();
        logResult(context.getString(R.string.main_starting_scan), true);
    }

    @Override
    protected final String doInBackground(Set<File>[] filesToScan) {
        running = true;

        //Pre
        fileHashesMD5.clear();
        fileHashesSHA1.clear();
        fileHashesSHA256.clear();

        publishProgress("\t" + context.getString(R.string.main_files_pending_scan, filesToScan[0].size() + "") + "\n", true);

        Database.loadDatabase(context, true, Database.signatureDatabases);
        int delayCount = 0;
        while (!Database.isDatabaseLoaded() && delayCount <= 90) {
            try {
                Thread.sleep(1000);
                delayCount++;
                //publishProgress("\t" + context.getString(R.string.main_database_loading), true);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        if (Database.isDatabaseLoaded()) {
            publishProgress("\t" + context.getString(R.string.main_database_loaded, Database.getSignatureCount() + "") + "\n", true);

            //Get file hashes
            publishProgress("\t" + context.getString(R.string.main_hashing_files), true);
            publishProgress("\t", true);
            int fileScannedCount = 0;
            int percentIncrement = (filesToScan[0].size() / 20);
            if (percentIncrement < 1) { //Prevent divide by zero
                percentIncrement = 1;
            }
            String spinnerCur = " ~ ";
            for (File file : filesToScan[0]) {
                if (this.isCancelled()) { //Allow quicker cancels
                    //publishProgress("\t" + context.getString(R.string.main_cancelled_scan), true);
                    running = false;
                    return null;
                }
                getFileHashes(file);
                fileScannedCount++;
                if ((fileScannedCount % percentIncrement) == 0) {
                    publishProgress(spinnerCur, true);
                    if (spinnerCur.equals(" = ")) {
                        spinnerCur = " ~ ";
                    } else {
                        spinnerCur = " = ";
                    }
                }
            }
            publishProgress("\n\t" + context.getString(R.string.main_hashing_done) + "\n", true);

            //Check the hashes
            checkSignature("MD5", fileHashesMD5, Database.signaturesMD5);
            checkSignature("SHA-1", fileHashesSHA1, Database.signaturesSHA1);
            checkSignature("SHA-256", fileHashesSHA256, Database.signaturesSHA256);

            //Post
            fileHashesMD5.clear();
            fileHashesSHA1.clear();
            fileHashesSHA256.clear();
            System.gc();
            Utils.FILES_SCANNED += filesToScan[0].size();
            publishProgress(context.getString(R.string.main_scanning_done, ((SystemClock.elapsedRealtime() - scanTime) / 1000) + "") + "\n\n\n\n", true);
        } else {
            publishProgress("\t" + context.getString(R.string.main_no_database_available), true);
            running = false;
        }
        running = false;
        return null;
    }

    @Override
    protected final void onProgressUpdate(Object... objects) {
        logResult((String) objects[0], (boolean) objects[1]);
    }

    private void checkSignature(String hashType, HashMap<String, File> signaturesToCheck, HashMap<String, String> signatureDatabase) {
        //XXX: TODO: This is a map with hash,file meaning multiple files with the same hashes will only match once!
        if (signatureDatabase.size() > 0) {
            for (Map.Entry<String, File> file : signaturesToCheck.entrySet()) {
                if (signatureDatabase.containsKey(file.getKey())) {
                    String result = signatureDatabase.get(file.getKey());
                    publishProgress(result + " in " + file.getValue().toString().replaceAll(Environment.getExternalStorageDirectory().toString(), "~"), false);
                }
            }
            publishProgress("\t" + context.getString(R.string.main_hash_scan_done, hashType) + "\n", true);
        } else {
            publishProgress("\t" + context.getString(R.string.main_no_database_available) + "\n", true);
        }
    }

    private void getFileHashes(File file) {
        try {
            InputStream fis = new FileInputStream(file);

            byte[] buffer = new byte[4096];
            int numRead;

            MessageDigest digestMD5 = MessageDigest.getInstance("MD5");
            MessageDigest digestSHA1 = MessageDigest.getInstance("SHA-1");
            MessageDigest digestSHA256 = MessageDigest.getInstance("SHA-256");

            do {
                numRead = fis.read(buffer);
                if (numRead > 0) {
                    digestMD5.update(buffer, 0, numRead);
                    digestSHA1.update(buffer, 0, numRead);
                    digestSHA256.update(buffer, 0, numRead);
                }
            } while (numRead != -1);

            fis.close();

            fileHashesMD5.put(String.format("%032x", new BigInteger(1, digestMD5.digest())).substring(0, Utils.MAX_HASH_LENGTH), file);
            fileHashesSHA1.put(String.format("%032x", new BigInteger(1, digestSHA1.digest())).substring(0, Utils.MAX_HASH_LENGTH), file);
            fileHashesSHA256.put(String.format("%064x", new BigInteger(1, digestSHA256.digest())).substring(0, Utils.MAX_HASH_LENGTH), file);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
